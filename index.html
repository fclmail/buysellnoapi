<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DEX Arbitrage</title>
  <script src="https://cdn.ethers.io/lib/ethers-5.7.2.umd.min.js"></script>
  <style>
    body {
      background-color: #0b1e3f;
      color: #fff;
      font-family: 'Segoe UI', sans-serif;
      padding: 20px;
      margin: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    h1 {
      text-align: center;
      margin-bottom: 20px;
    }

    input, button {
      width: 90%;
      max-width: 400px;
      padding: 12px;
      margin: 8px 0;
      font-size: 16px;
      border: none;
      border-radius: 8px;
      box-sizing: border-box;
    }

    input {
      background-color: #fff;
      color: #000;
    }

    button {
      background-color: #1e88e5;
      color: white;
      cursor: pointer;
    }

    button:hover {
      background-color: #1565c0;
    }

    #walletAddress, #usdcBalance {
      margin: 5px 0;
      font-weight: bold;
    }

    .section {
      width: 100%;
      max-width: 420px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
  </style>
</head>
<body>

  <h1>Polygon DEX Arbitrage</h1>

  <div class="section">
    <button onclick="connectWallet()">ðŸ”Œ Connect Wallet</button>
    <p id="walletAddress">Wallet: Not Connected</p>
    <p id="usdcBalance">USDC Balance: 0</p>

    <input id="tokenAddress" placeholder="Enter ERC-20 Token Address" />
    <input id="amountIn" placeholder="Amount of USDC to Use" />

    <button onclick="buyBalancerSellSushi()">Buy on Balancer â†’ Sell on Sushi</button>
    <button onclick="buySushiSellBalancer()">Buy on Sushi â†’ Sell on Balancer</button>
    <button onclick="testFunction()">ðŸ§ª Test Wallet Connection</button>
  </div>

  <script>
    let provider, signer, userAddress;

    const usdcAddress = "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174"; // USDC on Polygon
    const sushiRouterAddress = "0x1b02da8cb0d097eb8d57a175b88c7d8b47997506"; // SushiSwap
    const balancerVaultAddress = "0xBA12222222228d8Ba445958a75a0704d566BF2C8"; // Balancer

    const erc20Abi = [
      "function balanceOf(address) view returns (uint)",
      "function approve(address spender, uint amount) returns (bool)",
      "function allowance(address owner, address spender) view returns (uint)",
      "function decimals() view returns (uint8)"
    ];

    const sushiRouterAbi = [
      "function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts)"
    ];

    const balancerAbi = [
      "function swap(tuple(bytes32 poolId, uint8 kind, address assetIn, address assetOut, uint256 amount, bytes userData), tuple(address sender, bool fromInternalBalance, address recipient, bool toInternalBalance), uint256 limit, uint256 deadline) external returns (uint256)"
    ];

    async function connectWallet() {
      if (typeof window.ethereum !== 'undefined') {
        try {
          provider = new ethers.providers.Web3Provider(window.ethereum);
          await provider.send("eth_requestAccounts", []);
          signer = provider.getSigner();
          userAddress = await signer.getAddress();
          document.getElementById("walletAddress").innerText = `Wallet: ${userAddress}`;
          getUSDCBalance();
        } catch (err) {
          console.error("Connection rejected:", err);
          alert("Wallet connection failed.");
        }
      } else {
        // MetaMask not installed: use mobile deep link
        const dappUrl = window.location.href.replace(/^https?:\/\//, '');
        const metamaskDeepLink = `https://metamask.app.link/dapp/${dappUrl}`;
        window.location.href = metamaskDeepLink;
      }
    }

    async function getUSDCBalance() {
      const usdc = new ethers.Contract(usdcAddress, erc20Abi, provider);
      const balance = await usdc.balanceOf(userAddress);
      const decimals = await usdc.decimals();
      const formatted = ethers.utils.formatUnits(balance, decimals);
      document.getElementById("usdcBalance").innerText = `USDC Balance: ${formatted}`;
    }

    async function approveIfNeeded(token, spender, amount) {
      const contract = new ethers.Contract(token, erc20Abi, signer);
      const allowance = await contract.allowance(userAddress, spender);
      if (allowance.lt(amount)) {
        const tx = await contract.approve(spender, amount);
        await tx.wait();
      }
    }

    async function buyBalancerSellSushi() {
      const tokenAddress = document.getElementById("tokenAddress").value;
      const amount = ethers.utils.parseUnits(document.getElementById("amountIn").value, 6); // USDC has 6 decimals

      await approveIfNeeded(usdcAddress, balancerVaultAddress, amount);

      // Simulated Balancer buy
      alert("Simulating: Buy on Balancer");

      // Then approve for Sushi and sell
      await approveIfNeeded(tokenAddress, sushiRouterAddress, amount);
      const sushiRouter = new ethers.Contract(sushiRouterAddress, sushiRouterAbi, signer);
      const path = [tokenAddress, usdcAddress];
      const deadline = Math.floor(Date.now() / 1000) + 60 * 10;

      try {
        const tx = await sushiRouter.swapExactTokensForTokens(
          amount,
          0,
          path,
          userAddress,
          deadline
        );
        await tx.wait();
        alert("Token sold on Sushi");
        getUSDCBalance();
      } catch (err) {
        console.error(err);
        alert("Sushi sell failed");
      }
    }

    async function buySushiSellBalancer() {
      const tokenAddress = document.getElementById("tokenAddress").value;
      const amount = ethers.utils.parseUnits(document.getElementById("amountIn").value, 6); // USDC decimals

      await approveIfNeeded(usdcAddress, sushiRouterAddress, amount);
      const sushiRouter = new ethers.Contract(sushiRouterAddress, sushiRouterAbi, signer);
      const path = [usdcAddress, tokenAddress];
      const deadline = Math.floor(Date.now() / 1000) + 60 * 10;

      try {
        const tx = await sushiRouter.swapExactTokensForTokens(
          amount,
          0,
          path,
          userAddress,
          deadline
        );
        await tx.wait();
        alert("Token bought on Sushi");
      } catch (err) {
        console.error(err);
        alert("Sushi buy failed");
        return;
      }

      // Simulated Balancer sell
      alert("Simulating: Sell on Balancer");
      getUSDCBalance();
    }

    async function testFunction() {
      if (!signer) {
        alert("Wallet not connected.");
        return;
      }
      const address = await signer.getAddress();
      alert("Connected wallet: " + address);
    }
  </script>
</body>
</html>

