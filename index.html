<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DEX Arbitrage</title>
  <script src="https://cdn.ethers.io/lib/ethers-5.7.2.umd.min.js"></script>
  <style>
    body {
      background-color: #0b1e3f;
      color: #fff;
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    h1 {
      text-align: center;
      margin-bottom: 20px;
    }
    input, button {
      width: 90%;
      max-width: 400px;
      padding: 12px;
      margin: 8px 0;
      font-size: 16px;
      border: none;
      border-radius: 8px;
      box-sizing: border-box;
    }
    input {
      background-color: #fff;
      color: #000;
    }
    button {
      background-color: #1e88e5;
      color: white;
      cursor: pointer;
    }
    button:hover {
      background-color: #1565c0;
    }
    .section {
      width: 100%;
      max-width: 420px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #walletAddress, #usdcBalance {
      font-weight: bold;
      margin: 6px 0;
    }
  </style>
</head>
<body>
  <h1>Polygon DEX Arbitrage</h1>

  <div class="section">
    <button onclick="connectWallet()">üîå Connect Wallet</button>
    <p id="walletAddress">Wallet: Not Connected</p>
    <p id="usdcBalance">USDC Balance: 0</p>

    <input id="tokenAddress" placeholder="Enter ERC-20 Token Address (Polygon)" />
    <input id="amountIn" placeholder="Amount of USDC to Use" />

    <button onclick="buyBalancerSellSushi()">Buy on Balancer ‚Üí Sell on Sushi</button>
    <button onclick="buySushiSellBalancer()">Buy on Sushi ‚Üí Sell on Balancer</button>
    <button onclick="testFunction()">üß™ Test Wallet Connection</button>
  </div>

  <script>
    let provider, signer, userAddress;

    const usdcAddress = "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174"; // USDC on Polygon
    const sushiRouterAddress = "0x1b02da8cb0d097eb8d57a175b88c7d8b47997506"; // SushiSwap Router
    const balancerVaultAddress = "0xBA12222222228d8Ba445958a75a0704d566BF2C8"; // Balancer Vault

    const erc20Abi = [
      "function balanceOf(address) view returns (uint)",
      "function approve(address spender, uint amount) returns (bool)",
      "function allowance(address owner, address spender) view returns (uint)",
      "function decimals() view returns (uint8)"
    ];

    const sushiRouterAbi = [
      "function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts)"
    ];

    async function connectWallet() {
      if (typeof window.ethereum !== 'undefined') {
        try {
          provider = new ethers.providers.Web3Provider(window.ethereum, "any");
          await provider.send("eth_requestAccounts", []);
          signer = provider.getSigner();
          userAddress = await signer.getAddress();
          document.getElementById("walletAddress").innerText = `Wallet: ${userAddress}`;
          getUSDCBalance();
        } catch (err) {
          console.error("User rejected connection", err);
          alert("Wallet connection failed.");
        }
      } else {
        // MetaMask deep link fallback for mobile
        const dappUrl = window.location.href.replace(/^https?:\/\//, '');
        const metamaskLink = `https://metamask.app.link/dapp/${dappUrl}`;
        window.location.href = metamaskLink;
      }
    }

    async function getUSDCBalance() {
      if (!provider || !userAddress) return;
      const usdc = new ethers.Contract(usdcAddress, erc20Abi, provider);
      const balance = await usdc.balanceOf(userAddress);
      const decimals = await usdc.decimals();
      const formatted = ethers.utils.formatUnits(balance, decimals);
      document.getElementById("usdcBalance").innerText = `USDC Balance: ${formatted}`;
    }

    async function approveIfNeeded(token, spender, amount) {
      const contract = new ethers.Contract(token, erc20Abi, signer);
      const allowance = await contract.allowance(userAddress, spender);
      if (allowance.lt(amount)) {
        const tx = await contract.approve(spender, amount);
        await tx.wait();
      }
    }

    async function buyBalancerSellSushi() {
      const token = document.getElementById("tokenAddress").value;
      const amount = ethers.utils.parseUnits(document.getElementById("amountIn").value, 6);

      if (!signer || !token || amount.lte(0)) return alert("Missing input");

      await approveIfNeeded(usdcAddress, balancerVaultAddress, amount);
      alert("‚úÖ Simulated: Buy token on Balancer");

      await approveIfNeeded(token, sushiRouterAddress, amount);
      const sushi = new ethers.Contract(sushiRouterAddress, sushiRouterAbi, signer);
      const path = [token, usdcAddress];
      const deadline = Math.floor(Date.now() / 1000) + 600;

      try {
        const tx = await sushi.swapExactTokensForTokens(
          amount,
          0,
          path,
          userAddress,
          deadline
        );
        await tx.wait();
        alert("‚úÖ Token sold on Sushi");
        getUSDCBalance();
      } catch (err) {
        console.error(err);
        alert("‚ùå Sushi sell failed");
      }
    }

    async function buySushiSellBalancer() {
      const token = document.getElementById("tokenAddress").value;
      const amount = ethers.utils.parseUnits(document.getElementById("amountIn").value, 6);

      if (!signer || !token || amount.lte(0)) return alert("Missing input");

      await approveIfNeeded(usdcAddress, sushiRouterAddress, amount);
      const sushi = new ethers.Contract(sushiRouterAddress, sushiRouterAbi, signer);
      const path = [usdcAddress, token];
      const deadline = Math.floor(Date.now() / 1000) + 600;

      try {
        const tx = await sushi.swapExactTokensForTokens(
          amount,
          0,
          path,
          userAddress,
          deadline
        );
        await tx.wait();
        alert("‚úÖ Token bought on Sushi");
      } catch (err) {
        console.error(err);
        alert("‚ùå Sushi buy failed");
        return;
      }

      alert("‚úÖ Simulated: Sell token on Balancer");
      getUSDCBalance();
    }

    async function testFunction() {
      if (!signer) {
        alert("Wallet not connected.");
      } else {
        const address = await signer.getAddress();
        alert("Wallet Connected: " + address);
      }
    }
  </script>
</body>
</html>

